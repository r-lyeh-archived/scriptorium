/* Automatically generated by chibi-ffi; version: 0.3 */

#include <chibi/eval.h>

#include <arpa/inet.h>

#include <sys/types.h>

#include <sys/socket.h>

#include <netinet/in.h>

#include <netdb.h>

/* chibi-ffi should probably be able to detect these patterns automatically, */
/* but for now we manually check two special cases - accept should check for */
/* EWOULDBLOCK and block on the socket, and listen should automatically make */
/* sockets non-blocking. */

sexp sexp_accept (sexp ctx, sexp self, int sock, struct sockaddr* addr, socklen_t len) {
#if SEXP_USE_GREEN_THREADS
  sexp f;
#endif
  int res;
  res = accept(sock, addr, &len);
#if SEXP_USE_GREEN_THREADS
  if (res < 0 && errno == EWOULDBLOCK) {
    f = sexp_global(ctx, SEXP_G_THREADS_BLOCKER);
    if (sexp_applicablep(f)) {
      sexp_apply2(ctx, f, sexp_make_fixnum(sock), SEXP_FALSE);
      return sexp_global(ctx, SEXP_G_IO_BLOCK_ERROR);
    }
  }
  if (res >= 0)
    fcntl(res, F_SETFL, fcntl(res, F_GETFL) | O_NONBLOCK);
#endif
  return sexp_make_fileno(ctx, sexp_make_fixnum(res), SEXP_FALSE);
}

/* likewise sendto and recvfrom should suspend the thread gracefully */

#define sexp_zerop(x) ((x) == SEXP_ZERO || (sexp_flonump(x) && sexp_flonum_value(x) == 0.0))

sexp sexp_sendto (sexp ctx, sexp self, int sock, const void* buffer, size_t len, int flags, struct sockaddr* addr, socklen_t addr_len, sexp timeout) {
#if SEXP_USE_GREEN_THREADS
  sexp f;
#endif
  ssize_t res;
  res = sendto(sock, buffer, len, flags, addr, addr_len);
#if SEXP_USE_GREEN_THREADS
  if (res < 0 && errno == EWOULDBLOCK && !sexp_zerop(timeout)) {
    f = sexp_global(ctx, SEXP_G_THREADS_BLOCKER);
    if (sexp_applicablep(f)) {
      sexp_apply2(ctx, f, sexp_make_fixnum(sock), timeout);
      return sexp_global(ctx, SEXP_G_IO_BLOCK_ONCE_ERROR);
    }
  }
#endif
  return sexp_make_fixnum(res);
}

sexp sexp_recvfrom (sexp ctx, sexp self, int sock, void* buffer, size_t len, int flags, struct sockaddr* addr, socklen_t addr_len, sexp timeout) {
#if SEXP_USE_GREEN_THREADS
  sexp f;
#endif
  ssize_t res;
  res = recvfrom(sock, buffer, len, flags, addr, &addr_len);
#if SEXP_USE_GREEN_THREADS
  if (res < 0 && errno == EWOULDBLOCK && !sexp_zerop(timeout)) {
    f = sexp_global(ctx, SEXP_G_THREADS_BLOCKER);
    if (sexp_applicablep(f)) {
      sexp_apply2(ctx, f, sexp_make_fixnum(sock), timeout);
      return sexp_global(ctx, SEXP_G_IO_BLOCK_ONCE_ERROR);
    }
  }
#endif
  return sexp_make_fixnum(res);
}

/* If we're binding or listening on a socket from Scheme, we most */
/* likely want it to be non-blocking. */

sexp sexp_bind (sexp ctx, sexp self, int fd, struct sockaddr* addr, socklen_t addr_len) {
  int res = bind(fd, addr, addr_len);
#if SEXP_USE_GREEN_THREADS
  if (res >= 0)
    fcntl(fd, F_SETFL, fcntl(fd, F_GETFL) | O_NONBLOCK);
#endif
  return (res == 0) ? SEXP_TRUE : SEXP_FALSE;
}

sexp sexp_listen (sexp ctx, sexp self, sexp fileno, sexp backlog) {
  int fd, res;
  sexp_assert_type(ctx, sexp_filenop, SEXP_FILENO, fileno);
  sexp_assert_type(ctx, sexp_fixnump, SEXP_FIXNUM, backlog);
  fd = sexp_fileno_fd(fileno);
  res = listen(fd, sexp_unbox_fixnum(backlog));
#if SEXP_USE_GREEN_THREADS
  if (res >= 0)
    fcntl(fd, F_SETFL, fcntl(fd, F_GETFL) | O_NONBLOCK);
#endif
  return (res == 0) ? SEXP_TRUE : SEXP_FALSE;
}

/* Additional utilities. */

sexp sexp_sockaddr_name (sexp ctx, sexp self, struct sockaddr* addr) {
  char buf[24];
  /* struct sockaddr_in *sa = (struct sockaddr_in *)addr; */
  /* unsigned char *ptr = (unsigned char *)&(sa->sin_addr); */
  /* sprintf(buf, "%d.%d.%d.%d", ptr[0], ptr[1], ptr[2], ptr[3]); */
  inet_ntop(addr->sa_family,
            (addr->sa_family == AF_INET6 ?
             (void*)(&(((struct sockaddr_in6 *)addr)->sin6_addr)) :
             (void*)(&(((struct sockaddr_in *)addr)->sin_addr))),
            buf, 24);
  return sexp_c_string(ctx, buf, -1);
}

int sexp_sockaddr_port (sexp ctx, sexp self, struct sockaddr* addr) {
  struct sockaddr_in *sa = (struct sockaddr_in *)addr;
  return sa->sin_port;
}
/*
types: (addrinfo sockaddr)
enums: ()
*/

static sexp sexp_set_socket_option_x_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0, sexp arg1, sexp arg2, sexp arg3) {
  int err;
  int tmp3;
  sexp res;
  if (! (sexp_filenop(arg0) || sexp_fixnump(arg0)))
    return sexp_type_exception(ctx, self, SEXP_FILENO, arg0);
  if (! sexp_exact_integerp(arg1))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg1);
  if (! sexp_exact_integerp(arg2))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg2);
  if (! sexp_exact_integerp(arg3))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg3);
  tmp3 = sexp_sint_value(arg3);
  err = setsockopt((sexp_filenop(arg0) ? sexp_fileno_fd(arg0) : sexp_unbox_fixnum(arg0)), sexp_sint_value(arg1), sexp_sint_value(arg2), &tmp3, sizeof(int));
  if (err) {
  res = SEXP_FALSE;
  } else {
  res = SEXP_TRUE;
  }
  return res;
}

static sexp sexp_getsockopt_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0, sexp arg1, sexp arg2) {
  int err;
  int tmp3;
  socklen_t tmp4;
  sexp_gc_var3(res, res3, res4);
  if (! (sexp_filenop(arg0) || sexp_fixnump(arg0)))
    return sexp_type_exception(ctx, self, SEXP_FILENO, arg0);
  if (! sexp_exact_integerp(arg1))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg1);
  if (! sexp_exact_integerp(arg2))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg2);
  sexp_gc_preserve3(ctx, res, res3, res4);
  tmp4 = sizeof(int);
  err = getsockopt((sexp_filenop(arg0) ? sexp_fileno_fd(arg0) : sexp_unbox_fixnum(arg0)), sexp_sint_value(arg1), sexp_sint_value(arg2), &tmp3, &tmp4);
  if (err) {
  res = SEXP_FALSE;
  } else {
  res3 = sexp_make_integer(ctx, tmp3);
  res4 = sexp_make_integer(ctx, tmp4);
  res = SEXP_NULL;
  sexp_push(ctx, res, res4);
  sexp_push(ctx, res, res3);
  }
  sexp_gc_release3(ctx);
  return res;
}

static sexp sexp_get_peer_name_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0, sexp arg1) {
  int err;
  socklen_t tmp2;
  sexp res;
  sexp_gc_var1(res2);
  if (! (sexp_filenop(arg0) || sexp_fixnump(arg0)))
    return sexp_type_exception(ctx, self, SEXP_FILENO, arg0);
  if (! (sexp_pointerp(arg1) && (sexp_pointer_tag(arg1) == sexp_unbox_fixnum(sexp_opcode_arg2_type(self)))))
    return sexp_type_exception(ctx, self, sexp_unbox_fixnum(sexp_opcode_arg2_type(self)), arg1);
  sexp_gc_preserve1(ctx, res2);
  tmp2 = sizeof(struct sockaddr);
  err = getpeername((sexp_filenop(arg0) ? sexp_fileno_fd(arg0) : sexp_unbox_fixnum(arg0)), (struct sockaddr*)sexp_cpointer_value(arg1), &tmp2);
  if (err) {
  res = SEXP_FALSE;
  } else {
  res2 = sexp_make_integer(ctx, tmp2);
  res = res2;
  }
  sexp_gc_release1(ctx);
  return res;
}

static sexp sexp_sockaddr_port_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg2) {
  sexp res;
  if (! (sexp_pointerp(arg2) && (sexp_pointer_tag(arg2) == sexp_unbox_fixnum(sexp_opcode_arg3_type(self)))))
    return sexp_type_exception(ctx, self, sexp_unbox_fixnum(sexp_opcode_arg3_type(self)), arg2);
  res = sexp_make_integer(ctx, sexp_sockaddr_port(ctx, self, (struct sockaddr*)sexp_cpointer_value(arg2)));
  return res;
}

static sexp sexp_sockaddr_name_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg2) {
  sexp res;
  if (! (sexp_pointerp(arg2) && (sexp_pointer_tag(arg2) == sexp_unbox_fixnum(sexp_opcode_arg3_type(self)))))
    return sexp_type_exception(ctx, self, sexp_unbox_fixnum(sexp_opcode_arg3_type(self)), arg2);
  res = sexp_sockaddr_name(ctx, self, (struct sockaddr*)sexp_cpointer_value(arg2));
  return res;
}

static sexp sexp_open_socket_pair_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0, sexp arg1, sexp arg2) {
  int i, err;
  int tmp3[2];
  sexp res;
  sexp_gc_var1(res3);
  if (! sexp_exact_integerp(arg0))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg0);
  if (! sexp_exact_integerp(arg1))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg1);
  if (! sexp_exact_integerp(arg2))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg2);
  sexp_gc_preserve1(ctx, res3);
  err = socketpair(sexp_sint_value(arg0), sexp_sint_value(arg1), sexp_sint_value(arg2), tmp3);
  if (err) {
  res = SEXP_FALSE;
  } else {
  res3 = SEXP_NULL;
  for (i=2-1; i>=0; i--) {
    sexp_push(ctx, res3, SEXP_VOID);
    sexp_car(res3) = sexp_make_fileno(ctx, sexp_make_fixnum(tmp3[i]), SEXP_FALSE);
  }
  res = res3;
  }
  sexp_gc_release1(ctx);
  return res;
}

static sexp sexp_25_receive_x_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg2, sexp arg3, sexp arg5, sexp arg6, sexp arg7, sexp arg8) {
  sexp res;
  if (! (sexp_filenop(arg2) || sexp_fixnump(arg2)))
    return sexp_type_exception(ctx, self, SEXP_FILENO, arg2);
  if (! sexp_bytesp(arg3))
    return sexp_type_exception(ctx, self, SEXP_BYTES, arg3);
  if (! sexp_exact_integerp(arg5))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg5);
  if (! ((sexp_pointerp(arg6) && (sexp_pointer_tag(arg6) == sexp_unbox_fixnum(sexp_vector_ref(sexp_opcode_argn_type(self), SEXP_THREE)))) || sexp_not(arg6)))
    return sexp_type_exception(ctx, self, sexp_unbox_fixnum(sexp_vector_ref(sexp_opcode_argn_type(self), SEXP_THREE)), arg6);
  if (! sexp_exact_integerp(arg7))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg7);
  res = sexp_recvfrom(ctx, self, (sexp_filenop(arg2) ? sexp_fileno_fd(arg2) : sexp_unbox_fixnum(arg2)), sexp_bytes_data(arg3), sexp_bytes_length(arg3), sexp_sint_value(arg5), (struct sockaddr*)sexp_cpointer_maybe_null_value(arg6), sexp_sint_value(arg7), arg8);
  return res;
}

static sexp sexp_25_send_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg2, sexp arg3, sexp arg5, sexp arg6, sexp arg7, sexp arg8) {
  sexp res;
  if (! (sexp_filenop(arg2) || sexp_fixnump(arg2)))
    return sexp_type_exception(ctx, self, SEXP_FILENO, arg2);
  if (! sexp_bytesp(arg3))
    return sexp_type_exception(ctx, self, SEXP_BYTES, arg3);
  if (! sexp_exact_integerp(arg5))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg5);
  if (! ((sexp_pointerp(arg6) && (sexp_pointer_tag(arg6) == sexp_unbox_fixnum(sexp_vector_ref(sexp_opcode_argn_type(self), SEXP_THREE)))) || sexp_not(arg6)))
    return sexp_type_exception(ctx, self, sexp_unbox_fixnum(sexp_vector_ref(sexp_opcode_argn_type(self), SEXP_THREE)), arg6);
  if (! sexp_exact_integerp(arg7))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg7);
  res = sexp_sendto(ctx, self, (sexp_filenop(arg2) ? sexp_fileno_fd(arg2) : sexp_unbox_fixnum(arg2)), sexp_bytes_data(arg3), sexp_bytes_length(arg3), sexp_sint_value(arg5), (struct sockaddr*)sexp_cpointer_maybe_null_value(arg6), sexp_sint_value(arg7), arg8);
  return res;
}

static sexp sexp_connect_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0, sexp arg1, sexp arg2) {
  sexp res;
  if (! (sexp_filenop(arg0) || sexp_fixnump(arg0)))
    return sexp_type_exception(ctx, self, SEXP_FILENO, arg0);
  if (! (sexp_pointerp(arg1) && (sexp_pointer_tag(arg1) == sexp_unbox_fixnum(sexp_opcode_arg2_type(self)))))
    return sexp_type_exception(ctx, self, sexp_unbox_fixnum(sexp_opcode_arg2_type(self)), arg1);
  if (! sexp_exact_integerp(arg2))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg2);
  res = sexp_make_integer(ctx, connect((sexp_filenop(arg0) ? sexp_fileno_fd(arg0) : sexp_unbox_fixnum(arg0)), (struct sockaddr*)sexp_cpointer_value(arg1), sexp_sint_value(arg2)));
  return res;
}

static sexp sexp_socket_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0, sexp arg1, sexp arg2) {
  sexp res;
  if (! sexp_exact_integerp(arg0))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg0);
  if (! sexp_exact_integerp(arg1))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg1);
  if (! sexp_exact_integerp(arg2))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg2);
  res = sexp_make_fileno(ctx, sexp_make_fixnum(socket(sexp_sint_value(arg0), sexp_sint_value(arg1), sexp_sint_value(arg2))), SEXP_FALSE);
  return res;
}

static sexp sexp_accept_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg2, sexp arg3, sexp arg4) {
  sexp res;
  if (! (sexp_filenop(arg2) || sexp_fixnump(arg2)))
    return sexp_type_exception(ctx, self, SEXP_FILENO, arg2);
  if (! (sexp_pointerp(arg3) && (sexp_pointer_tag(arg3) == sexp_unbox_fixnum(sexp_vector_ref(sexp_opcode_argn_type(self), SEXP_ZERO)))))
    return sexp_type_exception(ctx, self, sexp_unbox_fixnum(sexp_vector_ref(sexp_opcode_argn_type(self), SEXP_ZERO)), arg3);
  if (! sexp_exact_integerp(arg4))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg4);
  res = sexp_accept(ctx, self, (sexp_filenop(arg2) ? sexp_fileno_fd(arg2) : sexp_unbox_fixnum(arg2)), (struct sockaddr*)sexp_cpointer_value(arg3), sexp_sint_value(arg4));
  return res;
}

static sexp sexp_listen_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg2, sexp arg3) {
  sexp res;
  res = sexp_listen(ctx, self, arg2, arg3);
  return res;
}

static sexp sexp_bind_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg2, sexp arg3, sexp arg4) {
  sexp res;
  if (! (sexp_filenop(arg2) || sexp_fixnump(arg2)))
    return sexp_type_exception(ctx, self, SEXP_FILENO, arg2);
  if (! (sexp_pointerp(arg3) && (sexp_pointer_tag(arg3) == sexp_unbox_fixnum(sexp_vector_ref(sexp_opcode_argn_type(self), SEXP_ZERO)))))
    return sexp_type_exception(ctx, self, sexp_unbox_fixnum(sexp_vector_ref(sexp_opcode_argn_type(self), SEXP_ZERO)), arg3);
  if (! sexp_exact_integerp(arg4))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg4);
  res = sexp_bind(ctx, self, (sexp_filenop(arg2) ? sexp_fileno_fd(arg2) : sexp_unbox_fixnum(arg2)), (struct sockaddr*)sexp_cpointer_value(arg3), sexp_sint_value(arg4));
  return res;
}

static sexp sexp_25_get_address_info_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0, sexp arg1, sexp arg2) {
  int err;
  struct addrinfo* tmp3;
  sexp res;
  sexp_gc_var1(res3);
  if (! (sexp_stringp(arg0) || sexp_not(arg0)))
    return sexp_type_exception(ctx, self, SEXP_STRING, arg0);
  if (! (sexp_stringp(arg1) || sexp_not(arg1)))
    return sexp_type_exception(ctx, self, SEXP_STRING, arg1);
  if (! ((sexp_pointerp(arg2) && (sexp_pointer_tag(arg2) == sexp_unbox_fixnum(sexp_opcode_arg3_type(self)))) || sexp_not(arg2)))
    return sexp_type_exception(ctx, self, sexp_unbox_fixnum(sexp_opcode_arg3_type(self)), arg2);
  sexp_gc_preserve1(ctx, res3);
  err = getaddrinfo(sexp_string_maybe_null_data(arg0), sexp_string_maybe_null_data(arg1), (struct addrinfo*)sexp_cpointer_maybe_null_value(arg2), &tmp3);
  if (err) {
  res = SEXP_FALSE;
  } else {
  res3 = sexp_make_cpointer(ctx, sexp_unbox_fixnum(sexp_vector_ref(sexp_opcode_argn_type(self), SEXP_ZERO)), tmp3, SEXP_FALSE, 1);
  res = res3;
  }
  sexp_gc_release1(ctx);
  return res;
}

static sexp sexp_freeaddrinfo_stub (sexp ctx, sexp self, sexp_sint_t n, sexp x) {
  if (sexp_cpointer_freep(x)) {
    freeaddrinfo(
#ifdef __cplusplus
(addrinfo*)
#endif
sexp_cpointer_value(x));
    sexp_cpointer_freep(x) = 0;
  }
  return SEXP_VOID;
}

static sexp sexp_25_make_address_info_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0, sexp arg1, sexp arg2, sexp arg3) {
  struct addrinfo* r;
  sexp_gc_var1(res);
  sexp_gc_preserve1(ctx, res);
  res = sexp_alloc_tagged(ctx, sexp_sizeof(cpointer), sexp_unbox_fixnum(sexp_opcode_return_type(self)));
  sexp_cpointer_value(res) = calloc(1, sizeof(struct addrinfo));
  r = (struct addrinfo*) sexp_cpointer_value(res);
  memset(r, 0, sizeof(struct addrinfo));
  sexp_freep(res) = 1;
  r->ai_family = sexp_sint_value(arg0);
  r->ai_socktype = sexp_sint_value(arg1);
  r->ai_protocol = sexp_sint_value(arg2);
  r->ai_flags = sexp_sint_value(arg3);
  sexp_gc_release1(ctx);
  return res;
}

static sexp sexp_addrinfo_get_ai_family (sexp ctx, sexp self, sexp_sint_t n, sexp x) {
  if (! (sexp_pointerp(x) && (sexp_pointer_tag(x) == sexp_unbox_fixnum(sexp_opcode_arg1_type(self)))))
    return sexp_type_exception(ctx, self, sexp_unbox_fixnum(sexp_opcode_arg1_type(self)), x);
  return sexp_make_integer(ctx, ((struct addrinfo*)sexp_cpointer_value(x))->ai_family);
}

static sexp sexp_addrinfo_get_ai_socktype (sexp ctx, sexp self, sexp_sint_t n, sexp x) {
  if (! (sexp_pointerp(x) && (sexp_pointer_tag(x) == sexp_unbox_fixnum(sexp_opcode_arg1_type(self)))))
    return sexp_type_exception(ctx, self, sexp_unbox_fixnum(sexp_opcode_arg1_type(self)), x);
  return sexp_make_integer(ctx, ((struct addrinfo*)sexp_cpointer_value(x))->ai_socktype);
}

static sexp sexp_addrinfo_get_ai_protocol (sexp ctx, sexp self, sexp_sint_t n, sexp x) {
  if (! (sexp_pointerp(x) && (sexp_pointer_tag(x) == sexp_unbox_fixnum(sexp_opcode_arg1_type(self)))))
    return sexp_type_exception(ctx, self, sexp_unbox_fixnum(sexp_opcode_arg1_type(self)), x);
  return sexp_make_integer(ctx, ((struct addrinfo*)sexp_cpointer_value(x))->ai_protocol);
}

static sexp sexp_addrinfo_get_ai_flags (sexp ctx, sexp self, sexp_sint_t n, sexp x) {
  if (! (sexp_pointerp(x) && (sexp_pointer_tag(x) == sexp_unbox_fixnum(sexp_opcode_arg1_type(self)))))
    return sexp_type_exception(ctx, self, sexp_unbox_fixnum(sexp_opcode_arg1_type(self)), x);
  return sexp_make_integer(ctx, ((struct addrinfo*)sexp_cpointer_value(x))->ai_flags);
}

static sexp sexp_addrinfo_get_ai_addr (sexp ctx, sexp self, sexp_sint_t n, sexp x) {
  if (! (sexp_pointerp(x) && (sexp_pointer_tag(x) == sexp_unbox_fixnum(sexp_opcode_arg1_type(self)))))
    return sexp_type_exception(ctx, self, sexp_unbox_fixnum(sexp_opcode_arg1_type(self)), x);
  return sexp_make_cpointer(ctx, sexp_unbox_fixnum(sexp_opcode_return_type(self)), ((struct addrinfo*)sexp_cpointer_value(x))->ai_addr, x, 0);
}

static sexp sexp_addrinfo_get_ai_addrlen (sexp ctx, sexp self, sexp_sint_t n, sexp x) {
  if (! (sexp_pointerp(x) && (sexp_pointer_tag(x) == sexp_unbox_fixnum(sexp_opcode_arg1_type(self)))))
    return sexp_type_exception(ctx, self, sexp_unbox_fixnum(sexp_opcode_arg1_type(self)), x);
  return sexp_make_unsigned_integer(ctx, ((struct addrinfo*)sexp_cpointer_value(x))->ai_addrlen);
}

static sexp sexp_addrinfo_get_ai_next (sexp ctx, sexp self, sexp_sint_t n, sexp x) {
  if (! (sexp_pointerp(x) && (sexp_pointer_tag(x) == sexp_unbox_fixnum(sexp_opcode_arg1_type(self)))))
    return sexp_type_exception(ctx, self, sexp_unbox_fixnum(sexp_opcode_arg1_type(self)), x);
  return sexp_make_cpointer(ctx, sexp_unbox_fixnum(sexp_opcode_return_type(self)), ((struct addrinfo*)sexp_cpointer_value(x))->ai_next, x, 0);
}

static sexp sexp_make_sockaddr_stub (sexp ctx, sexp self, sexp_sint_t n) {
  struct sockaddr* r;
  sexp_gc_var1(res);
  sexp_gc_preserve1(ctx, res);
  res = sexp_alloc_tagged(ctx, sexp_sizeof(cpointer), sexp_unbox_fixnum(sexp_opcode_return_type(self)));
  sexp_cpointer_value(res) = calloc(1, sizeof(struct sockaddr));
  r = (struct sockaddr*) sexp_cpointer_value(res);
  memset(r, 0, sizeof(struct sockaddr));
  sexp_freep(res) = 1;
  sexp_gc_release1(ctx);
  return res;
}


sexp sexp_init_library (sexp ctx, sexp self, sexp_sint_t n, sexp env, const char* version, const sexp_abi_identifier_t abi) {
  sexp sexp_addrinfo_type_obj;
  sexp sexp_sockaddr_type_obj;
  sexp_gc_var3(name, tmp, op);
  if (!(sexp_version_compatible(ctx, version, sexp_version)
        && sexp_abi_compatible(ctx, abi, SEXP_ABI_IDENTIFIER)))
    return SEXP_ABI_ERROR;
  sexp_gc_preserve3(ctx, name, tmp, op);
  name = sexp_intern(ctx, "socket-opt/sndlowat", 19);
  sexp_env_define(ctx, env, name, tmp=sexp_make_integer(ctx, SO_SNDLOWAT));
  name = sexp_intern(ctx, "socket-opt/rcvlowat", 19);
  sexp_env_define(ctx, env, name, tmp=sexp_make_integer(ctx, SO_RCVLOWAT));
  name = sexp_intern(ctx, "socket-opt/dontroute", 20);
  sexp_env_define(ctx, env, name, tmp=sexp_make_integer(ctx, SO_DONTROUTE));
  name = sexp_intern(ctx, "socket-opt/rcvbuf", 17);
  sexp_env_define(ctx, env, name, tmp=sexp_make_integer(ctx, SO_RCVBUF));
  name = sexp_intern(ctx, "socket-opt/sndbuf", 17);
  sexp_env_define(ctx, env, name, tmp=sexp_make_integer(ctx, SO_SNDBUF));
  name = sexp_intern(ctx, "socket-opt/oobinline", 20);
  sexp_env_define(ctx, env, name, tmp=sexp_make_integer(ctx, SO_OOBINLINE));
  name = sexp_intern(ctx, "socket-opt/keepalive", 20);
  sexp_env_define(ctx, env, name, tmp=sexp_make_integer(ctx, SO_KEEPALIVE));
  name = sexp_intern(ctx, "socket-opt/reuseaddr", 20);
  sexp_env_define(ctx, env, name, tmp=sexp_make_integer(ctx, SO_REUSEADDR));
  name = sexp_intern(ctx, "socket-opt/broadcast", 20);
  sexp_env_define(ctx, env, name, tmp=sexp_make_integer(ctx, SO_BROADCAST));
  name = sexp_intern(ctx, "socket-opt/debug", 16);
  sexp_env_define(ctx, env, name, tmp=sexp_make_integer(ctx, SO_DEBUG));
  name = sexp_intern(ctx, "level/socket", 12);
  sexp_env_define(ctx, env, name, tmp=sexp_make_integer(ctx, SOL_SOCKET));
  name = sexp_intern(ctx, "ai/numeric-host", 15);
  sexp_env_define(ctx, env, name, tmp=sexp_make_integer(ctx, AI_NUMERICHOST));
  name = sexp_intern(ctx, "ai/canonname", 12);
  sexp_env_define(ctx, env, name, tmp=sexp_make_integer(ctx, AI_CANONNAME));
  name = sexp_intern(ctx, "ai/passive", 10);
  sexp_env_define(ctx, env, name, tmp=sexp_make_integer(ctx, AI_PASSIVE));
  name = sexp_intern(ctx, "ip-proto/udp", 12);
  sexp_env_define(ctx, env, name, tmp=sexp_make_integer(ctx, IPPROTO_UDP));
  name = sexp_intern(ctx, "ip-proto/tcp", 12);
  sexp_env_define(ctx, env, name, tmp=sexp_make_integer(ctx, IPPROTO_TCP));
  name = sexp_intern(ctx, "ip-proto/icmp", 13);
  sexp_env_define(ctx, env, name, tmp=sexp_make_integer(ctx, IPPROTO_ICMP));
  name = sexp_intern(ctx, "ip-proto/ip", 11);
  sexp_env_define(ctx, env, name, tmp=sexp_make_integer(ctx, IPPROTO_IP));
  name = sexp_intern(ctx, "socket-type/raw", 15);
  sexp_env_define(ctx, env, name, tmp=sexp_make_integer(ctx, SOCK_RAW));
  name = sexp_intern(ctx, "socket-type/datagram", 20);
  sexp_env_define(ctx, env, name, tmp=sexp_make_integer(ctx, SOCK_DGRAM));
  name = sexp_intern(ctx, "socket-type/stream", 18);
  sexp_env_define(ctx, env, name, tmp=sexp_make_integer(ctx, SOCK_STREAM));
  name = sexp_intern(ctx, "address-family/inet6", 20);
  sexp_env_define(ctx, env, name, tmp=sexp_make_integer(ctx, AF_INET6));
  name = sexp_intern(ctx, "address-family/inet", 19);
  sexp_env_define(ctx, env, name, tmp=sexp_make_integer(ctx, AF_INET));
  name = sexp_intern(ctx, "address-family/unix", 19);
  sexp_env_define(ctx, env, name, tmp=sexp_make_integer(ctx, AF_UNIX));
  name = sexp_intern(ctx, "address-family/unspecified", 26);
  sexp_env_define(ctx, env, name, tmp=sexp_make_integer(ctx, AF_UNSPEC));
  name = sexp_c_string(ctx, "addrinfo", -1);
  sexp_addrinfo_type_obj = sexp_register_c_type(ctx, name, sexp_freeaddrinfo_stub);
  tmp = sexp_string_to_symbol(ctx, name);
  sexp_env_define(ctx, env, tmp, sexp_addrinfo_type_obj);
  sexp_type_slots(sexp_addrinfo_type_obj) = SEXP_NULL;
  sexp_push(ctx, sexp_type_slots(sexp_addrinfo_type_obj), sexp_intern(ctx, "ai_next", -1));
  sexp_push(ctx, sexp_type_slots(sexp_addrinfo_type_obj), sexp_intern(ctx, "ai_addrlen", -1));
  sexp_push(ctx, sexp_type_slots(sexp_addrinfo_type_obj), sexp_intern(ctx, "ai_addr", -1));
  sexp_push(ctx, sexp_type_slots(sexp_addrinfo_type_obj), sexp_intern(ctx, "ai_flags", -1));
  sexp_push(ctx, sexp_type_slots(sexp_addrinfo_type_obj), sexp_intern(ctx, "ai_protocol", -1));
  sexp_push(ctx, sexp_type_slots(sexp_addrinfo_type_obj), sexp_intern(ctx, "ai_socktype", -1));
  sexp_push(ctx, sexp_type_slots(sexp_addrinfo_type_obj), sexp_intern(ctx, "ai_family", -1));
  sexp_type_getters(sexp_addrinfo_type_obj) = sexp_make_vector(ctx, SEXP_SEVEN, SEXP_FALSE);
  sexp_type_setters(sexp_addrinfo_type_obj) = sexp_make_vector(ctx, SEXP_SEVEN, SEXP_FALSE);
  tmp = sexp_make_type_predicate(ctx, name, sexp_addrinfo_type_obj);
  name = sexp_intern(ctx, "address-info?", 13);
  sexp_env_define(ctx, env, name, tmp);
  name = sexp_c_string(ctx, "sockaddr", -1);
  sexp_sockaddr_type_obj = sexp_register_c_type(ctx, name, sexp_finalize_c_type);
  tmp = sexp_string_to_symbol(ctx, name);
  sexp_env_define(ctx, env, tmp, sexp_sockaddr_type_obj);
  tmp = sexp_make_type_predicate(ctx, name, sexp_sockaddr_type_obj);
  name = sexp_intern(ctx, "sockaddr?", 9);
  sexp_env_define(ctx, env, name, tmp);
  op = sexp_define_foreign(ctx, env, "make-sockaddr", 0, (sexp_proc1)sexp_make_sockaddr_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(sexp_type_tag(sexp_sockaddr_type_obj));
  }
  op = sexp_define_foreign(ctx, env, "address-info-next", 1, (sexp_proc1)sexp_addrinfo_get_ai_next);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(sexp_type_tag(sexp_addrinfo_type_obj));
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(sexp_type_tag(sexp_addrinfo_type_obj));
  }
  if (sexp_vectorp(sexp_type_getters(sexp_addrinfo_type_obj))) sexp_vector_set(sexp_type_getters(sexp_addrinfo_type_obj), SEXP_SIX, op);
  op = sexp_define_foreign(ctx, env, "address-info-address-length", 1, (sexp_proc1)sexp_addrinfo_get_ai_addrlen);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(sexp_type_tag(sexp_addrinfo_type_obj));
  }
  if (sexp_vectorp(sexp_type_getters(sexp_addrinfo_type_obj))) sexp_vector_set(sexp_type_getters(sexp_addrinfo_type_obj), SEXP_FIVE, op);
  op = sexp_define_foreign(ctx, env, "address-info-address", 1, (sexp_proc1)sexp_addrinfo_get_ai_addr);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(sexp_type_tag(sexp_sockaddr_type_obj));
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(sexp_type_tag(sexp_addrinfo_type_obj));
  }
  if (sexp_vectorp(sexp_type_getters(sexp_addrinfo_type_obj))) sexp_vector_set(sexp_type_getters(sexp_addrinfo_type_obj), SEXP_FOUR, op);
  op = sexp_define_foreign(ctx, env, "address-info-flags", 1, (sexp_proc1)sexp_addrinfo_get_ai_flags);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(sexp_type_tag(sexp_addrinfo_type_obj));
  }
  if (sexp_vectorp(sexp_type_getters(sexp_addrinfo_type_obj))) sexp_vector_set(sexp_type_getters(sexp_addrinfo_type_obj), SEXP_THREE, op);
  op = sexp_define_foreign(ctx, env, "address-info-protocol", 1, (sexp_proc1)sexp_addrinfo_get_ai_protocol);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(sexp_type_tag(sexp_addrinfo_type_obj));
  }
  if (sexp_vectorp(sexp_type_getters(sexp_addrinfo_type_obj))) sexp_vector_set(sexp_type_getters(sexp_addrinfo_type_obj), SEXP_TWO, op);
  op = sexp_define_foreign(ctx, env, "address-info-socket-type", 1, (sexp_proc1)sexp_addrinfo_get_ai_socktype);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(sexp_type_tag(sexp_addrinfo_type_obj));
  }
  if (sexp_vectorp(sexp_type_getters(sexp_addrinfo_type_obj))) sexp_vector_set(sexp_type_getters(sexp_addrinfo_type_obj), SEXP_ONE, op);
  op = sexp_define_foreign(ctx, env, "address-info-family", 1, (sexp_proc1)sexp_addrinfo_get_ai_family);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(sexp_type_tag(sexp_addrinfo_type_obj));
  }
  if (sexp_vectorp(sexp_type_getters(sexp_addrinfo_type_obj))) sexp_vector_set(sexp_type_getters(sexp_addrinfo_type_obj), SEXP_ZERO, op);
  op = sexp_define_foreign(ctx, env, "%make-address-info", 4, (sexp_proc1)sexp_25_make_address_info_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(sexp_type_tag(sexp_addrinfo_type_obj));
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg2_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg3_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_argn_type(op) = sexp_make_vector(ctx, SEXP_ONE, sexp_make_fixnum(SEXP_OBJECT));
    sexp_vector_set(sexp_opcode_argn_type(op), SEXP_ZERO, sexp_make_fixnum(SEXP_FIXNUM));
  }
  op = sexp_define_foreign(ctx, env, "freeaddrinfo", 1, (sexp_proc1)sexp_freeaddrinfo_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = SEXP_VOID;
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(sexp_type_tag(sexp_addrinfo_type_obj));
  }
  op = sexp_define_foreign(ctx, env, "set-socket-option!", 4, (sexp_proc1)sexp_set_socket_option_x_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_OBJECT);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_FILENO);
    sexp_opcode_arg2_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg3_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_argn_type(op) = sexp_make_vector(ctx, SEXP_TWO, sexp_make_fixnum(SEXP_OBJECT));
    sexp_vector_set(sexp_opcode_argn_type(op), SEXP_ZERO, sexp_make_fixnum(SEXP_FIXNUM));
    sexp_vector_set(sexp_opcode_argn_type(op), SEXP_ONE, sexp_make_fixnum(SEXP_FIXNUM));
  }
  op = sexp_define_foreign(ctx, env, "getsockopt", 3, (sexp_proc1)sexp_getsockopt_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_OBJECT);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_FILENO);
    sexp_opcode_arg2_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg3_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_argn_type(op) = sexp_make_vector(ctx, SEXP_TWO, sexp_make_fixnum(SEXP_OBJECT));
    sexp_vector_set(sexp_opcode_argn_type(op), SEXP_ZERO, sexp_make_fixnum(SEXP_FIXNUM));
    sexp_vector_set(sexp_opcode_argn_type(op), SEXP_ONE, sexp_make_fixnum(SEXP_FIXNUM));
  }
  op = sexp_define_foreign(ctx, env, "get-peer-name", 2, (sexp_proc1)sexp_get_peer_name_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_OBJECT);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_FILENO);
    sexp_opcode_arg2_type(op) = sexp_make_fixnum(sexp_type_tag(sexp_sockaddr_type_obj));
    sexp_opcode_arg3_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
  }
  op = sexp_define_foreign(ctx, env, "sockaddr-port", 1, (sexp_proc1)sexp_sockaddr_port_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg3_type(op) = sexp_make_fixnum(sexp_type_tag(sexp_sockaddr_type_obj));
  }
  op = sexp_define_foreign(ctx, env, "sockaddr-name", 1, (sexp_proc1)sexp_sockaddr_name_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_OBJECT);
    sexp_opcode_arg3_type(op) = sexp_make_fixnum(sexp_type_tag(sexp_sockaddr_type_obj));
  }
  op = sexp_define_foreign(ctx, env, "open-socket-pair", 3, (sexp_proc1)sexp_open_socket_pair_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_OBJECT);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg2_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg3_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_argn_type(op) = sexp_make_vector(ctx, SEXP_ONE, sexp_make_fixnum(SEXP_OBJECT));
    sexp_vector_set(sexp_opcode_argn_type(op), SEXP_ZERO, sexp_make_fixnum(SEXP_FILENO));
  }
  op = sexp_define_foreign(ctx, env, "%receive!", 6, (sexp_proc1)sexp_25_receive_x_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_OBJECT);
    sexp_opcode_arg3_type(op) = sexp_make_fixnum(SEXP_FILENO);
    sexp_opcode_argn_type(op) = sexp_make_vector(ctx, SEXP_SIX, sexp_make_fixnum(SEXP_OBJECT));
    sexp_vector_set(sexp_opcode_argn_type(op), SEXP_ZERO, sexp_make_fixnum(SEXP_BYTES));
    sexp_vector_set(sexp_opcode_argn_type(op), SEXP_ONE, sexp_make_fixnum(SEXP_FIXNUM));
    sexp_vector_set(sexp_opcode_argn_type(op), SEXP_TWO, sexp_make_fixnum(SEXP_FIXNUM));
    sexp_vector_set(sexp_opcode_argn_type(op), SEXP_THREE, sexp_make_fixnum(sexp_type_tag(sexp_sockaddr_type_obj)));
    sexp_vector_set(sexp_opcode_argn_type(op), SEXP_FOUR, sexp_make_fixnum(SEXP_FIXNUM));
  }
  op = sexp_define_foreign(ctx, env, "%send", 6, (sexp_proc1)sexp_25_send_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_OBJECT);
    sexp_opcode_arg3_type(op) = sexp_make_fixnum(SEXP_FILENO);
    sexp_opcode_argn_type(op) = sexp_make_vector(ctx, SEXP_SIX, sexp_make_fixnum(SEXP_OBJECT));
    sexp_vector_set(sexp_opcode_argn_type(op), SEXP_ZERO, sexp_make_fixnum(SEXP_BYTES));
    sexp_vector_set(sexp_opcode_argn_type(op), SEXP_ONE, sexp_make_fixnum(SEXP_FIXNUM));
    sexp_vector_set(sexp_opcode_argn_type(op), SEXP_TWO, sexp_make_fixnum(SEXP_FIXNUM));
    sexp_vector_set(sexp_opcode_argn_type(op), SEXP_THREE, sexp_make_fixnum(sexp_type_tag(sexp_sockaddr_type_obj)));
    sexp_vector_set(sexp_opcode_argn_type(op), SEXP_FOUR, sexp_make_fixnum(SEXP_FIXNUM));
  }
  op = sexp_define_foreign(ctx, env, "connect", 3, (sexp_proc1)sexp_connect_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_FILENO);
    sexp_opcode_arg2_type(op) = sexp_make_fixnum(sexp_type_tag(sexp_sockaddr_type_obj));
    sexp_opcode_arg3_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
  }
  op = sexp_define_foreign(ctx, env, "socket", 3, (sexp_proc1)sexp_socket_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_FILENO);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg2_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg3_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
  }
  op = sexp_define_foreign(ctx, env, "accept", 3, (sexp_proc1)sexp_accept_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_OBJECT);
    sexp_opcode_arg3_type(op) = sexp_make_fixnum(SEXP_FILENO);
    sexp_opcode_argn_type(op) = sexp_make_vector(ctx, SEXP_TWO, sexp_make_fixnum(SEXP_OBJECT));
    sexp_vector_set(sexp_opcode_argn_type(op), SEXP_ZERO, sexp_make_fixnum(sexp_type_tag(sexp_sockaddr_type_obj)));
    sexp_vector_set(sexp_opcode_argn_type(op), SEXP_ONE, sexp_make_fixnum(SEXP_FIXNUM));
  }
  op = sexp_define_foreign(ctx, env, "listen", 2, (sexp_proc1)sexp_listen_stub);
  op = sexp_define_foreign(ctx, env, "bind", 3, (sexp_proc1)sexp_bind_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_OBJECT);
    sexp_opcode_arg3_type(op) = sexp_make_fixnum(SEXP_FILENO);
    sexp_opcode_argn_type(op) = sexp_make_vector(ctx, SEXP_TWO, sexp_make_fixnum(SEXP_OBJECT));
    sexp_vector_set(sexp_opcode_argn_type(op), SEXP_ZERO, sexp_make_fixnum(sexp_type_tag(sexp_sockaddr_type_obj)));
    sexp_vector_set(sexp_opcode_argn_type(op), SEXP_ONE, sexp_make_fixnum(SEXP_FIXNUM));
  }
  op = sexp_define_foreign(ctx, env, "%get-address-info", 3, (sexp_proc1)sexp_25_get_address_info_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_OBJECT);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_STRING);
    sexp_opcode_arg2_type(op) = sexp_make_fixnum(SEXP_STRING);
    sexp_opcode_arg3_type(op) = sexp_make_fixnum(sexp_type_tag(sexp_addrinfo_type_obj));
    sexp_opcode_argn_type(op) = sexp_make_vector(ctx, SEXP_ONE, sexp_make_fixnum(SEXP_OBJECT));
    sexp_vector_set(sexp_opcode_argn_type(op), SEXP_ZERO, sexp_make_fixnum(sexp_type_tag(sexp_addrinfo_type_obj)));
  }
  sexp_gc_release3(ctx);
  return SEXP_VOID;
}

